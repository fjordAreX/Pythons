# в новую функцию добавляешь старую функцию и модифицируешь ее - это декоратор

def decor_make(f):
    def wrapper(): # создаем ибо make = decor(make), в таком случае без обертки получится make() = decor(make)(), так нельзя
        print("Код декоратора")
        f()
        print('Второй код декоратора')
    return wrapper



@decor_make # make становится равным decor, у которого аргумент - функция make
def make():
    enter = input('Enter smth: ')
    print(enter)

h = make # идентификатор функции получаем

h()    # вызываем самую функцию

# вызываем make() - перекидывает на decor(make()), оттуда нас перекидывает на wrapper(),
# там исполняется новый код и код из make(),
# мы возвращаем wrapper и таким образом по какой-то непонятной мне логике make = wrapper => make() = wrapper()

# вроде понял: мы вызываем make, через decorator мы получаем decor(make) => make = decor(make), decor(make) = wrapper =>
# два идентификатора методов равны - make & wrapper => при вызове make() мы вызываем вложенную функцию wrapper(),
# которая исполняет свой код и код из метода, который внутри
